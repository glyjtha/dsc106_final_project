<!DOCTYPE html>
<meta charset="utf-8">
<body style="font-family: sans-serif; background: white;">

  <div style="display: flex; align-items: center; width: 80%; margin: 20px auto; gap: 10px; font-size: 12px;">
    <span>Before sleep deprivation</span>
    <input type="range" id="tSlider" min="0" max="1" step="0.01" value="0" style="flex: 1; accent-color: #4C9AFF;">
    <span>After sleep deprivation</span>
  </div>
  

  <div style="position: relative; width: 1000px; margin: auto;">
    <svg id="chart" width="1000" height="420"></svg>

    <img src="eye-open.png" id="eyeOpen"
         style="position: absolute; top: 160px; left: 470px; width: 60px; opacity: 1;">
    <img src="yawn.png" id="yawn"
         style="position: absolute; top: 160px; left: 470px; width: 60px; opacity: 0;">
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  d3.csv("SD_CANTAB_DB_public.csv", d3.autoType).then(rawData => {
    const clean      = rawData.filter(d => d["Subject ID"]);
    const beforeData = clean.filter(d => d["Subject ID"].endsWith("_before"));
    const afterData  = clean.filter(d => d["Subject ID"].endsWith("_after"));
    const ids        = beforeData.map(d => d["Subject ID"].replace("_before", ""));

    const metricMap = {
      RTI: d => +d["RTIFMRT"],
      PAL: d => +d["PALTE"],
      SWM: d => +d["SWMS"],
      RVP: d => +d["RVPA"]
    };

    const svg = d3.select("#chart");
    const W = +svg.attr("width"),
          H = +svg.attr("height"),
          pad = 40;

    const metrics = ["RTI", "PAL", "SWM", "RVP"];
    const plotWidth = 220;
    const spacing = 20;
    const fullMetricNames = {
      RTI: "Reaction Time (RTI)",
      PAL: "Paired-Associate Learning Errors (PAL)",
      SWM: "Spatial Working Memory Errors (SWM)",
      RVP: "Sustained Attention Sensitivity (RVP)"
    };

    const plots = metrics.map((metric, i) => {
      const x0 = i * (plotWidth + spacing) + pad;
      const g = svg.append("g").attr("transform", `translate(${x0},0)`);

      // 添加 metric title
      g.append("text")
        .attr("x", plotWidth / 2)
        .attr("y", 24)
        .attr("text-anchor", "middle")
        .style("font-size", "13px")
        .style("fill", "#333")
        .text(fullMetricNames[metric]);


      const gx = g.append("g").attr("transform", `translate(0,${H - pad})`);
      const gy = g.append("g").attr("transform", `translate(${pad},0)`);

      const pts = g.append("g").attr("class", "pts").selectAll("circle")
        .data(ids)
        .join("circle")
          .attr("r", 5)
          .attr("fill", "#6c5ce7")
          .attr("stroke", "white")
          .attr("stroke-width", 1.2)
          .attr("opacity", 0.9);

      return { metric, gx, gy, pts };
    });

    function update(t) {
    const betterIfHigher = {
      RTI: false,
      PAL: false,
      SWM: false,
      RVP: true
    };

    plots.forEach(({ metric, gx, gy, pts }) => {
      const getVal = metricMap[metric];
      const allVals = beforeData.map(getVal).concat(afterData.map(getVal));

      const xScale = d3.scalePoint()
        .domain(ids)
        .range([pad, plotWidth - pad]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(allVals)).nice()
        .range([H - pad, pad + 20]);

      gx.call(d3.axisBottom(xScale)
            .tickSize(0)
            .tickFormat(d => d))
        .selectAll("text")
          .attr("transform", "rotate(-65)")
          .style("text-anchor", "end")
          .style("font-size", "9px");

      gy.call(d3.axisLeft(yScale).ticks(4));

      // Interpolate color: from base blue to red or green
      const baseColor = d3.color("#6c5ce7"); // original blue

      pts.data(beforeData.map((d, i) => {
        const v0 = getVal(d);
        const v1 = getVal(afterData[i]);
        const isImproving = betterIfHigher[metric] ? v1 > v0 : v1 < v0;
        const targetColor = d3.color(isImproving ? "#00b894" : "#d63031"); // green or red
        const interpColor = d3.interpolateRgb(baseColor, targetColor)(t);

        return {
          id: ids[i],
          val: v0 + (v1 - v0) * t,
          color: interpColor
        };
      }))
      .join("circle")
        .transition().duration(60)
          .attr("cx", d => xScale(d.id))
          .attr("cy", d => yScale(d.val))
          .attr("fill", d => d.color);
    });

    // emoji opacity
    d3.select("#eyeOpen").style("opacity", 1 - t);
    d3.select("#yawn").style("opacity", t);
  }


    update(0);

    d3.select("#tSlider").on("input", function () {
      const t = +this.value;
      update(t);
    });
  });
  </script>
</body>
